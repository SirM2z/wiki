# 正则表达式

## 常用元字符

| 代码 | 说明           |
| --- | ------------- |
| .   | 匹配除换行符以外的任意字符 |
| \w  | 匹配字母，数字，下划线，汉字 |
| \s  | 匹配任意的空白符 |
| \d  | 匹配数字 |
| \b  | 匹配单词的开始或结束 |
| ^   | 匹配字符串的开始，在 `[]` 内表示非 |
| $   | 匹配字符串的结束 |

## 常用限定符

| 代码   | 说明           |
| ----- | ------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ?     | 重复零次或一次 |
| {n}   | 重复 `n` 次 |
| {n,}  | 重复 `n` 次或更多次 |
| {n,m} | 重复 `n` 到 `m` 次 |

## 常用反义

| 代码      | 说明           |
| -------- | ------------- |
| \W       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S       | 匹配任意不是空白符的字符 |
| \D       | 匹配任意非数字的字符 |
| \B       | 匹配不是单词开头或结束的位置 |
| [^x]     | 匹配除了 `x` 以外的任意字符 |
| [^aeiou] | 匹配除了 `aeiou` 这几个字母以外的任意字符 |

- 🌰：`\S+` 匹配不包含空白符的字符串
- 🌰：`<a[^>]+>` 匹配用尖括号括起来的以 `a` 开头的字符串

## 其它元字符

| 代码             | 说明           |
| --------------- | ------------- |
| \a              | 报警字符（打印它的效果是电脑嘀一声） |
| \b              | 通常是单词分界位置，但如果在字符类里使用代表退格 |
| \t              | 制表符，`Tab` |
| \r              | 回车 |
| \v              | 竖向制表符 |
| \f              | 换页符 |
| \n              | 换行符 |
| \e              | `Escape` |
| \0nn            | `ASCII` 代码中八进制代码为 `nn` 的字符 |
| \xnn            | `ASCII` 代码中十六进制代码为 `nn` 的字符 |
| \unnnn          | `Unicode` 代码中十六进制代码为 `nnnn` 的字符 |
| \cN             | `ASCII` 控制字符。比如 `\cC` 代表 `Ctrl+C` |
| \A              | 字符串开头（类似 `^`，但不受处理多行选项的影响） |
| \Z              | 字符串结尾或行尾（不受处理多行选项的影响） |
| \z              | 字符串结尾（类似 `$`，但不受处理多行选项的影响） |
| \G              | 当前搜索的开头 |
| \p{name}        | `Unicode` 中命名为 `name` 的字符类，例如 `\p{IsGreek}` |
| (?>exp)         | 贪婪子表达式 |
| (?&lt;x>-&lt;y>exp)   | 平衡组 |
| (?im-nsx:exp)   | 在子表达式 `exp` 中改变处理选项 |
| (?im-nsx)       | 为表达式后面的部分改变处理选项 |
| (?(exp)yes|no)  | 把 `exp` 当作零宽正向先行断言，如果在这个位置能匹配，使用 `yes` 作为此组的表达式；否则使用 `no` |
| (?(exp)yes)     | 同上，只是使用空表达式作为 `no` |
| (?(name)yes|no) | 如果命名为 `name` 的组捕获到了内容，使用 `yes` 作为表达式；否则使用 `no` |
| (?(name)yes)    | 同上，只是使用空表达式作为 `no` |

## `[]` 中括号作用

1. 中括号中的元字符表示它本身的含义。如 `/[.]/` 匹配 `.`
2. 中括号中的内容表示多选一。如 `/[12]/` 匹配 `1` 或 `2`

### 🌰 匹配 `18-165` 范围的数字

`/^1[89]$|^[2-9]\d$|^1[0-5]\d$|^16[0-5]$/`

解释：

1. `^1[89]$` 匹配 `1` 开头，`8` 或 `9` 结尾，即 `18,19`
2. `^[2-9]\d$` 匹配 `2` 到 `9` 开头，数字结尾，即 `20-99`
3. `^1[0-5]\d$` 匹配 `1` 开头，第二位数字为 `0-5`，以数字结尾，即 `100-159`
4. `^16[0-5]$` 匹配 `16` 开头，`0-5` 结尾的数字，即 `160-165`

### 🌰 处理字符串中的空格为一个空格

```js
const str = "  abc   abc    abc abc  ";
str.replace(/ +/g, ' ');
```

## `()` 小括号作用

1. 改变默认优先级
2. 分组引用
3. 分组捕获

### 改变默认优先级

正则表达式 `/^18|19$/` 可以匹配 `18, 19, 189, 119, 181119, 819` 等，不符合常规逻辑。引入 `()` 后：`/^(18|19)$/`，只匹配 `18, 19`。

### 分组引用

正则表达式 `/^([a-z])([a-z])\2\1$/` 可以匹配 `abba, oppo` 类型字符串，其中 `\2` 即引用了第二个小括号中的匹配模式，`\1` 则引用了第一个小括号中的匹配模式

### 分组捕获

捕获身份证号（假）：`128391198709142321` 中的信息

1. `128391` 前六位表示地狱信息
2. `19870914` 接着八位表示出生年月日
3. `2` 倒数第二位，奇数为男，偶数为女

```js
const reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
console.log(reg.exec('128391198709142321'));
// ["128391198709142321", "128391", "1987", "09", "14", "2", "1", index: 0, input: "128391198709142321", groups: undefined, length: 7]
```
即：需要捕获的部分用小括号包起来

注：`?:` 可以阻止分组捕获，如下
```js
let reg = /(\d+)/;
let str = 'abc123';
reg.exec(str); // ['123', '123', index: 3, input: 'abc123']
reg = /(?:\d+)/;
reg.exec(str); // ['123', index: 3, input: 'abc123']
```

## 正则捕获

把一个字符串中匹配到的部分获取到

- 正则方法：`exec`， `test`
- 字符串方法：`replace`， `split`， `match`

### `exec` 的懒惰型

观察以下表达式
```js
const reg = /\d+/g;
const str = 'I am 26 years old and weigh 60 kg.';
// 这里只匹配到了第一个数字，并没有匹配到 60
console.log(reg.exec(str)); // ["26", index: 5, input: "I am 26 years old and weigh 60 kg."]
// 再执行一次
console.log(reg.exec(str)); // ["60", index: 28, input: "I am 26 years old and weigh 60 kg."]
// 再执行一次
console.log(reg.exec(str)); // null
```

可以看出 `exec` 捕获具有懒惰型，需要多次调用才能捕获多个匹配项，实现方法解决懒惰型

```js
RegExp.prototype.MyExec = function(str) {
  if (!this.global) {
    return this.exec(str);
  }
  let res = [];
  let val = this.exec(str);
  while(val) {
    res.push(val[0]);
    val = this.exec(str);
  }
  return res;
}
const reg = /\d+/g;
const str = 'I am 26 years old and weigh 60 kg.';
console.log(reg.MyExec(str)); // ["26", "60"]
```

### `match` 解决正则捕获懒惰型

```js
const reg = /\d+/g;
const str = 'I am 26 years old and weigh 60 kg.';
console.log(str.match(reg)); // ["26", "60"]
```

### `match` 会忽略分组捕获

`exec` 可以捕获整个正则表达式的匹配项，也可以捕获分组，如下
```js
const str = 'abc123def456';
const reg = /[a-z]{3}(\d+)[a-z]{3}(\d+)/g;
reg.exec(str); // ['abc123def456', '123', '456', index: 0, input: 'abc123def456',]
str.match(reg); // ['abc123def456']
```

## 常用正则

### 有效数字

1. 正数 负数 零
2. 小数 整数

测试用例：
- 可以：`0, +0, -0, 1.2, -1.2, 2.0`
- 不可以：`02, 01.2, 2., .3, -.1`

1. `/^[+-]?(\d|([1-9]\d+))(\.\d+)?$/`
2. `/(^[+-]\d+|^[1-9]\d*|^0)(\.\d+)?$/`

### 手机号码

1. 11 位数字
2. 以 1 开头

`/^1\d{10}$/`

### 中文姓名

1. 中文汉字 `[\u4E00-\u9FA5]`： 中文 `Unicode` 编码从第一个汉字到最后一个汉字
2. 尼古拉斯·赵四

`/^[\u4E00-\u9FA5]{2,}(·[\u4E00-\u9FA5]{2,})?$/`

### 邮箱

`xxxx@xxx.xx.xx`
1. `@` 左边部分：数字，字母，下划线，`-`，`.`
    - `-`，`.` 不能作为开头
    - `-`，`.` 不能连续出现
    - `-`，`.` 不能作为结尾
2. `@` 右边部分： `xxx.xx.xx`， `xxx-xx-xxx.xx.xx`， `xxx.xx.xx.xx.xx`

`/^\w+([-.]\w+)*@[A-Za-z0-9]+([-.][A-Za-z0-9]+)*(\.[A-Za-z0-9]+)$/`
